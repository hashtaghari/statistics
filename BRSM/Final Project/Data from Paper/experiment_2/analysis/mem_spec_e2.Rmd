---
title: 'Memory Specificity Analyses: Experiment 2'
author: "Kate Nussenbaum"
date: "11/13/23"
output: 
  html_document:
    df_print: paged
    theme: flatly
    toc: yes
    toc_depth: 4
    toc_float: yes
---

```{=html}
<style type="text/css">
h1.title {
font-size: 38px;
}
h1 { /* Header 1 */
font-size: 28px;
}
h2 { /* Header 2 */
font-size: 22px;
}
h3 { /* Header 3 */
font-size: 18px;
}

</style>
```

------------------------------------------------------------------------

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F, warning = F, message = F, cache = F)
knitr::opts_chunk$set(fig.path = "results/figures/concrete/")
knitr::opts_chunk$set(fig.height = 4, dpi = 600)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
```

```{r load needed libraries}
library(tidyverse)
library(glue)
library(afex)
library(ggpubr)
library(pander)
library(sjPlot)
library(latex2exp)
library(pROC)
```

```{r define functions}
scale_this <- function(x){
  (x - mean(x, na.rm=TRUE)) / sd(x, na.rm=TRUE)
}

se <- function(x){
    sd(x, na.rm = T)/sqrt(length(x))
}
```

```{r plot theme}

#define colors to use for plots
color4 =  "#d94f70"
color5 = "#f88f58"
color3 = "#45b5aa"
color1 = "#FFCA4B"
color2 = "#6364a5"

#define plotting theme
mem_theme <- theme(panel.background = element_rect(fill='transparent'),
                   axis.line = element_line(color='black'),
                   panel.border = element_rect(color = 'black', fill = "transparent"),
                   panel.grid.minor = element_line(color='transparent'),
                   axis.title.x = element_text(size=16, vjust=-.25),
                   axis.title.y = element_text(size=16, vjust=1),
                   axis.text.x = element_text(size=12, colour="black"),
                   axis.text.y = element_text(size=12, colour="black"),
                   legend.text=element_text(size=12),
                   legend.title = element_text(size = 14),
                   plot.title = element_text(size=16, face = "bold", hjust = .5), 
                   strip.text.x = element_text(size=12), 
                   strip.text.y = element_text(size=12), 
                   strip.background = element_rect(colour= "black", fill = "transparent"))
```

# Import and process data 
```{r import age data}

#read in subject ages
sub_ages <- read_csv(glue('data/e2_sub_ages.csv')) 

#create list of all included subjects with subject ids, age, age group
subject_list <- sub_ages %>%
    mutate(age = as.numeric(age)) %>%
    mutate(age_group = case_when(age < 13 ~ "Children",
                                 age >= 13 & age < 18 ~ "Adolescents",
                                 age >= 18 ~ "Adults")) %>%
    mutate(age_group = factor(age_group, levels = c("Children", "Adolescents", "Adults")))
```



```{r format data for learning analyses}
#clean and rename
learning_data <- read_csv('data/e2_learning_data.csv') %>%
    mutate(reward_condition = as.factor(case_when(block_condition == 1 ~ "Category-Predictive",
                                        block_condition == 2 ~ "Exemplar-Predictive"))) %>%
    group_by(subject_id, task_block, stimulus) %>% 
    mutate(stimulus_repetition = rank(learning_trial)) %>%
    ungroup() %>%
    mutate(correct_response_made = optimal_choice) %>%
    ungroup() %>%
    group_by(subject_id, reward_condition) %>%
    mutate(within_condition_block_num = as.numeric(factor(rank(block_order)))) %>%
    ungroup()

# add age
learning_data <- full_join(learning_data, subject_list, by = c('subject_id'))

#factor subject id
learning_data$subject_id <- factor(learning_data$subject_id)
```


# Learning
## Model: Correct responses by age, trial, block number, and block condition
```{r fit learning model}
learning_cr_model_data <- learning_data %>%
    select(correct_response_made, age, age_group, learning_trial, reward_condition, block_order, within_condition_block_num, subject_id) %>%
    drop_na()

#scale variables
learning_cr_model_data$learning_trial_scaled <- scale_this(learning_cr_model_data$learning_trial)
learning_cr_model_data$block_number_scaled <- scale_this(learning_cr_model_data$within_condition_block_num)
learning_cr_model_data$age_group <- factor(learning_cr_model_data$age_group)

#run model
learning_cr_model <- mixed(correct_response_made ~ age_group * learning_trial_scaled * reward_condition * block_number_scaled + (learning_trial_scaled * reward_condition * block_number_scaled || subject_id),
                           data = learning_cr_model_data,
                           family = "binomial",
                           method = "LRT",
                           expand_re = T,
                           control = glmerControl(optimizer = "bobyqa"))
nice(learning_cr_model)

#significant effects of:
# age group
# trial
# block condition
# block number
# age group x trial
# age group x block condition
# trial x block condition
```

```{r display learning model}
learning_cr_model.glmer <- mixed(correct_response_made ~ age_group * learning_trial_scaled * reward_condition * block_number_scaled + (learning_trial_scaled * reward_condition * block_number_scaled || subject_id),
                           data = learning_cr_model_data,
                           family = "binomial",
                           method = "LRT",
                           expand_re = T,
                           control = glmerControl(optimizer = "bobyqa"),
                           return = "merMod")

tab_model(learning_cr_model.glmer,
          digits = 4,
          show.intercept = F,
          show.est = T,
          show.ci = F,
          show.se = T,
          show.stat = F,
          show.p = F,
          string.se = "SE")
```

## Figure 5A: Correct response by block condition, stimulus repetition, and age group
```{r plot learning across age groups, fig.width = 6}

# Plot correct response as a function of reward condition and stimulus repetition 
correct_response_summary_sub <- learning_data %>%
    group_by(reward_condition, stimulus_repetition, subject_id, age_group) %>%
    summarize(mean_correct = mean(correct_response_made, na.rm = T))

correct_response_summary <- correct_response_summary_sub  %>%
    group_by(reward_condition, stimulus_repetition, age_group) %>%
    summarize(group_mean_correct = mean(mean_correct, na.rm = T),
              se_correct = se(mean_correct))

#group means
correct_response_plot <- ggplot(correct_response_summary, 
                                    aes(x = stimulus_repetition, 
                                        color = reward_condition,
                                        y = group_mean_correct)) +
    facet_grid(cols = vars(age_group)) +
    geom_point() +
    geom_line() +
    geom_errorbar(aes(ymin = group_mean_correct - se_correct, ymax = group_mean_correct + se_correct), 
                  width = .1) + 
    xlab("Stimulus Repetition") +
    ylab("Proportion of Correct Responses") +
    scale_color_manual(values = c(color1, color2),
                       name = "Block Condition") +
    geom_hline(yintercept = .33, linetype = "dashed") +
    scale_y_continuous(limits = c(.2, 1), breaks = c(.3, .5, .7, .9)) +
    mem_theme  +
    theme(legend.position = "top")
correct_response_plot
```

## Supplementary Figure:  Correct response by block condition and block number 
```{r plot learning by block number}

# Plot correct response as a function of reward condition and stimulus repetition 
correct_response_summary_sub <- learning_data %>% 
    filter(rt > 0) %>%
    group_by(within_condition_block_num, reward_condition, subject_id) %>%
    summarize(mean_correct = mean(correct_response_made, na.rm = T))

#group means
correct_response_plot <- ggplot(correct_response_summary_sub, 
                                    aes(x = factor(within_condition_block_num), 
                                        fill = reward_condition,
                                        y = mean_correct)) +
    geom_boxplot(alpha = .7) +
    xlab("Block Number") +
    ylab("Proportion of Correct Responses") +
    scale_fill_manual(values = c(color1, color2),
                       name = "Block Condition") +
    geom_hline(yintercept = .33, linetype = "dashed") +
    mem_theme  +
    theme(legend.position = "top")
correct_response_plot
```



## Figure 5B: Generalization by block condition, category repetition, age group
```{r plot generalization, fig.width = 6}

# add category to learning data frame
learning_data <- learning_data %>%
    separate(stimulus,
             into = c(NA, "image"),
             sep = "/") %>%
    mutate(stim_num = parse_number(image)) %>%
    separate(image,
             into = c("category", NA),
             sep = "([123456])",
             remove=FALSE)

# determine category repetition number
learning_data <- learning_data %>%
    group_by(subject_id, task_block, category, age_group) %>%
    mutate(category_rep = rank(learning_trial))

# determine correct responses as a function of stimulus rep and category rep
correct_response_category_rep <- learning_data %>%
    mutate(category_rep_recoded = case_when(category_rep < 7 ~ category_rep,
                                            category_rep > 7 ~ 8)) %>%
    group_by(reward_condition, stimulus_repetition, category_rep_recoded, age_group) %>%
    summarize(group_mean_correct = mean(correct_response_made, na.rm = T),
              se_correct = se(correct_response_made),
              N = n())  %>%
    filter(stimulus_repetition == 1) %>%
    drop_na()

#plot
correct_response_category_rep_plot <- ggplot(correct_response_category_rep, 
                                aes(x = category_rep_recoded,
                                    color = reward_condition,
                                    y = group_mean_correct)) +
    facet_grid(cols = vars(age_group)) +
    geom_point() +
    geom_smooth(method = "lm", aes(fill = reward_condition)) +
    geom_errorbar(aes(ymin = group_mean_correct - se_correct, ymax = group_mean_correct + se_correct), 
                  width = .1) + 
    xlab("Category Repetition") +
    ylab("Correct Responses to 1st Stim.") +
    scale_color_manual(values = c(color1, color2),
                       name = "Block Condition") + 
    scale_fill_manual(values = c(color1, color2),
                       name = "Block Condition") + 
    geom_hline(yintercept = .33, linetype = "dashed") +
    mem_theme +
    scale_x_continuous(breaks = c(2, 4, 6, 8),
                       labels = c("2", "4", "6", "8+")
                       ) +
    theme(legend.position = "top")
correct_response_category_rep_plot
```


## Model: Correct response to first appearance of each stimulus
```{r fit generalization model}
cr_first_rep_data  <- learning_data %>%
    select(correct_response_made, age, age_group, category_rep, reward_condition, block_order, subject_id, stimulus_repetition, within_condition_block_num) %>%
    filter(stimulus_repetition == 1) %>%
    drop_na()

#scale variables
cr_first_rep_data$category_rep_scaled <- scale_this(cr_first_rep_data$category_rep)
cr_first_rep_data$block_number_scaled <- scale_this(cr_first_rep_data$within_condition_block_num)
cr_first_rep_data$age_group <- factor(cr_first_rep_data$age_group)

#run model
cr_first_rep_model <- mixed(correct_response_made ~ age_group * category_rep_scaled * reward_condition * block_number_scaled  + (reward_condition * block_number_scaled || subject_id),
                           data = cr_first_rep_data,
                           family = "binomial",
                           method = "LRT",
                           expand_re = T,
                           control = glmerControl(optimizer = "bobyqa"))
nice(cr_first_rep_model)

# with full random effects: singular fit
# removed interactions between random slope: still singular fit
# removed block number random slope: still singular fit
# removed category rep random slope, put block number and interaction back in: converges


# Significant effects of:
# category rep
# block condition
# age group x block condition
# category rep x block condition
```

```{r display generalization model}
cr_first_rep_model.glmer <- mixed(correct_response_made ~ age_group * category_rep_scaled * reward_condition * block_number_scaled  + (reward_condition * block_number_scaled || subject_id),
                           data = cr_first_rep_data,
                           family = "binomial",
                           method = "LRT",
                           expand_re = T,
                           control = glmerControl(optimizer = "bobyqa"),
                           return = "merMod")

tab_model(cr_first_rep_model.glmer,
          digits = 4,
          show.intercept = F,
          show.est = T,
          show.ci = F,
          show.se = T,
          show.stat = F,
          show.p = F,
          string.se = "SE")
```


## Model: Category win-stay lose-shift 
```{r fit WSLS model}

#determine win-stay lose shift behavior across age group and blocks
learning_data <- learning_data %>% 
    group_by(subject_id, block_order, category) %>%
    mutate(prior_cat_stim = lag(image), #previous stimulus
           prior_cat_response = lag(option_selected), #previous response
           prior_cat_points = lag(points), #previous outcome (win or lose) 
           category_stay = case_when(prior_cat_response == option_selected ~ 1,
                                prior_cat_response != option_selected ~ 0),
           same_stim = case_when(image == prior_cat_stim ~ 1,
                                 image != prior_cat_stim ~ 0)) %>%
    ungroup()  %>%
        mutate(WSLS = case_when(prior_cat_points == 1 & category_stay == 1 ~ 1, 
                            prior_cat_points == 1 & category_stay == 0 ~ 0,
                            prior_cat_points == -1 & category_stay == 1 ~ 0, 
                            prior_cat_points == -1 & category_stay == 0 ~ 1))

wsls_model_data <- learning_data %>% 
    select(subject_id, age_group, WSLS, learning_trial, reward_condition, block_order, within_condition_block_num) %>%
    drop_na() 

#scale variables
wsls_model_data$learning_trial_scaled <- scale_this(wsls_model_data$learning_trial)
wsls_model_data$block_number_scaled <- scale_this(wsls_model_data$within_condition_block_num)
wsls_model_data$age_group <- factor(wsls_model_data$age_group)

#run model
wsls_model <- mixed(WSLS ~ age_group * learning_trial_scaled * reward_condition * block_number_scaled  + (learning_trial_scaled * reward_condition * block_number_scaled || subject_id),
                    data = wsls_model_data,
                    family = "binomial",
                    method = "LRT",
                    expand_re = T,
                    control = glmerControl(optimizer = "bobyqa"))
nice(wsls_model)

# significant effects of:
# trial
# block condition
# block order
# age group x block condition
# trial x block condition
# block condition x block order
# age group x trial x block condition
```

```{r display win stay lose shift model}
wsls_model.glmer <- mixed(WSLS ~ age_group * learning_trial_scaled * reward_condition * block_number_scaled  + (learning_trial_scaled * reward_condition * block_number_scaled || subject_id),
                    data = wsls_model_data,
                    family = "binomial",
                    method = "LRT",
                    expand_re = T,
                    control = glmerControl(optimizer = "bobyqa"),
                    return = "merMod")

tab_model(wsls_model.glmer,
          digits = 4,
          show.intercept = F,
          show.est = T,
          show.ci = F,
          show.se = T,
          show.stat = F,
          show.p = F,
          string.se = "SE")
```

## Supplementary Figure: WSLS by age group
```{r plot WSLS by age group, fig.width = 6}

#first determine prior response and prior reward to previous category appearance
learning_data <- learning_data %>% 
    group_by(subject_id, block_order, category) %>%
    mutate(prior_cat_stim = lag(image), #previous stimulus
           prior_cat_response = lag(option_selected), #previous response
           prior_cat_points = lag(points), #previous outcome (win or lose) 
           category_stay = case_when(prior_cat_response == option_selected ~ 1,
                                prior_cat_response != option_selected ~ 0),
           same_stim = case_when(image == prior_cat_stim ~ 1,
                                 image != prior_cat_stim ~ 0)) %>%
    ungroup()  %>%
        mutate(WSLS = case_when(prior_cat_points == 1 & category_stay == 1 ~ 1, 
                            prior_cat_points == 1 & category_stay == 0 ~ 0,
                            prior_cat_points == -1 & category_stay == 1 ~ 0, 
                            prior_cat_points == -1 & category_stay == 0 ~ 1))

#determine win-stay lose shift behavior across age group and blocks
win_stay_lose_shift <- learning_data %>%
    filter(same_stim == 0) %>% #different stim only
    mutate(trial_group = floor(learning_trial/12 + 71/72)) %>%
    group_by(subject_id, age, age_group, reward_condition, trial_group) %>%
    summarize(mean_WSLS = mean(WSLS, na.rm = T),
              se_WSLS = se(WSLS)) %>%
    drop_na()

#plot
WSLS_plot <- ggplot(win_stay_lose_shift, aes(x = trial_group, y = mean_WSLS, fill = reward_condition)) +
    facet_grid(cols = vars(age_group)) +
    geom_boxplot(data = filter(win_stay_lose_shift, trial_group == 1)) + 
    geom_boxplot(data = filter(win_stay_lose_shift, trial_group == 2)) +
    geom_boxplot(data = filter(win_stay_lose_shift, trial_group == 3)) +
    geom_boxplot(data = filter(win_stay_lose_shift, trial_group == 4)) + 
    geom_boxplot(data = filter(win_stay_lose_shift, trial_group == 5)) +
    geom_boxplot(data = filter(win_stay_lose_shift, trial_group == 6)) +
    scale_fill_manual(values = c(color1, color2),
                      name = "Block Condition") + 
    scale_color_manual(values = c(color1, color2),
                      name = "Block Condition") + 
    geom_hline(yintercept = .5, linetype = "dashed") +
    xlab("Trial Group (10 trials)") +
    ylab("Category WSLS") +
    scale_x_continuous(breaks = c(1, 2, 3, 4, 5, 6), labels = c(1,2,3, 4, 5, 6)) +
    coord_cartesian(ylim = c(.3, 1)) +
    mem_theme +
    theme(legend.position = "top")
WSLS_plot 
```


## Supplementary Figure: WSLS by block number
```{r WSLS plot with block number}

#determine win-stay lose shift behavior across age group and blocks
win_stay_lose_shift <- learning_data %>%
    filter(same_stim == 0) %>% #different stim only
    mutate(trial_group = floor(learning_trial/12 + 71/72)) %>%
    group_by(subject_id, reward_condition, within_condition_block_num) %>%
    summarize(mean_WSLS = mean(WSLS, na.rm = T),
              se_WSLS = se(WSLS)) %>%
    drop_na()

#plot
WSLS_plot <- ggplot(win_stay_lose_shift, aes(x = factor(within_condition_block_num), y = mean_WSLS, fill = reward_condition)) +
    geom_boxplot(alpha = .7) +
    scale_fill_manual(values = c(color1, color2),
                      name = "Block Condition") + 
    geom_hline(yintercept = .5, linetype = "dashed") +
    xlab("Block Number") +
    ylab("Category WSLS") +
    mem_theme +
    theme(legend.position = "top")
WSLS_plot 
```


# Memory
```{r process in memory data from both age_groups}
#combine and process
memory_data <- read_csv('data/e2_memory_data.csv') %>%
    filter(is.na(mem_acc) == F)

#relabel foil type and reward condition
memory_data$foil_type <- factor(memory_data$foil_type, levels = c("old", "exemplar", "category"),
                                  labels = c("Old", "Novel Exemplar", "Novel Category"))

memory_data$reward_condition <- factor(memory_data$block_condition,
                                            levels = c(1, 2),
                                            labels = c("Category-Predictive", "Exemplar-Predictive"))

#combine with subject list
memory_data <- inner_join(memory_data, subject_list, by = c("subject_id"))
```


## Memory delay stats
```{r memory delay stats}
mem_delay_overall_data <- memory_data %>%
    select(subject_id, age_group, memory_delay) %>%
    unique() %>%
    summarize(mean_delay = mean(memory_delay, na.rm = T),
              sd_delay = sd(memory_delay, na.rm = T),
              min_delay = min(memory_delay, na.rm = T),
              max_delay = max(memory_delay, na.rm = T))
pander(mem_delay_overall_data)

mem_delay_data <- memory_data %>%
    select(subject_id, age_group, memory_delay) %>%
    unique() %>%
    group_by(age_group) %>%
    summarize(mean_delay = mean(memory_delay, na.rm = T),
              sd_delay = sd(memory_delay, na.rm = T),
              min_delay = min(memory_delay, na.rm = T),
              max_delay = max(memory_delay, na.rm = T))
pander(mem_delay_data)

mem_delay_distribution <- memory_data %>%
    select(subject_id, age_group, memory_delay) %>%
    unique() %>%
    group_by(memory_delay, age_group) %>%
    summarize(N = n())
pander(mem_delay_distribution)
```

```{r fit ROC curves for each participant and derive AUC}
exemplar_AUCs <- memory_data %>%
    filter(foil_type != "Novel Category") %>%
    select(subject_id,  memory_delay, age_group, reward_condition, correct_mem_response, conf_rating) %>%
    group_by(subject_id, memory_delay, age_group, reward_condition) %>%
    mutate(exemplar = as.numeric(roc(correct_mem_response ~ conf_rating)$auc)) %>%
    select(subject_id, memory_delay, reward_condition, exemplar) %>%
    unique()

category_AUCs <- memory_data %>%
    filter(foil_type != "Novel Exemplar") %>%
    select(subject_id, memory_delay,  age_group, reward_condition, correct_mem_response, conf_rating) %>%
    group_by(subject_id, memory_delay,  age_group, reward_condition) %>%
    mutate(category = as.numeric(roc(correct_mem_response ~ conf_rating)$auc)) %>%
    select(subject_id,  memory_delay, reward_condition, category) %>%
    unique()

#combine AUCs into single data frame
participant_AUCs <- full_join(exemplar_AUCs, category_AUCs, by = c("subject_id", "age_group", "reward_condition", "memory_delay")) %>%
    pivot_longer(cols = c(exemplar, category),
                 names_to = "foil_type",
                 values_to = "AUC")

```


## Figure 5D: AUC values by age group, memory specificity, block condition
```{r auc plot 2, fig.height = 8, fig.width = 5}
auc_means <- participant_AUCs %>%
    group_by(age_group, foil_type, reward_condition) %>%
    summarize(mean_auc = mean(AUC, na.rm = T),
              se_auc = se(AUC))

auc_plot <- ggplot(participant_AUCs) +
    facet_grid(cols = vars(age_group), rows = vars(foil_type)) +
    geom_hline(yintercept = .5, linetype = "dashed") +
       geom_point(data = participant_AUCs, aes(x = reward_condition, color = foil_type, y = AUC), shape = 95, size = 20, alpha = .2) + 
    geom_point(data = auc_means, aes(x = reward_condition, y = mean_auc), color = "black", size = 2) +
    geom_errorbar(data = auc_means, aes(x = reward_condition, y = mean_auc, ymin = mean_auc - se_auc, ymax = mean_auc + se_auc), color = "black", width = .1) +
    geom_line(data = auc_means, aes(x = reward_condition, y = mean_auc, group = age_group), color = "black", linewidth = .5) +
    scale_color_manual(values = c(color1, color2), name = "Block Condition") +
    xlab("Block Condition") +
    ylab("Memory Performance (AUC)") +
    mem_theme +
    theme(axis.text.x = element_text(angle = 50, hjust = 1),
          legend.position = "none")
auc_plot
```

## Model: AUCs by age group, reward condition, memory specificity
```{r fit auc model}
aucs <- full_join(participant_AUCs, subject_list, by = c("subject_id", "age_group"))

#factor age group
aucs$age_group <- factor(aucs$age_group)

#run model
auc_model <- mixed(AUC ~ age_group * reward_condition * foil_type + (1|subject_id),
                   data = aucs,
                   method = "S")
nice(auc_model)

#effects of:
# reward condition
# foil type
# marginal  reward condition x foil type
```

```{r display auc model}

#run model
auc_model.lmer <- mixed(AUC ~ age_group * reward_condition * foil_type + (1|subject_id),
                   data = aucs,
                   method = "S",
                   return = "merMod")

tab_model(auc_model.lmer,
          digits = 4,
          show.intercept = F,
          show.est = T,
          show.ci = F,
          show.se = T,
          show.stat = F,
          show.p = F,
          string.se = "SE")
```


## Model: AUCs by age, reward condition, foil type, delay
```{r fit auc model with delay}

#scale variables
aucs$age_group <- factor(aucs$age_group)
aucs$mem_delay_scaled <- scale_this(aucs$memory_delay)

#run model
auc_model.delay <- mixed(AUC ~ age_group * reward_condition * foil_type * mem_delay_scaled + (1|subject_id),
                   data = aucs,
                   method = "S")
nice(auc_model.delay)

#effects of:
# reward condition
# foil type
# marginal reward condition x foil type 
# foil type x memory delay
```

```{r display auc model with delay}

#run model
auc_model_delay.lmer <- mixed(AUC ~ age_group * reward_condition * foil_type * mem_delay_scaled + (1|subject_id),
                   data = aucs,
                   method = "S",
                   return = "merMod")

tab_model(auc_model_delay.lmer,
          digits = 4,
          show.intercept = F,
          show.est = T,
          show.ci = F,
          show.se = T,
          show.stat = F,
          show.p = F,
          string.se = "SE")
```

## Supplementary Figure: AUC values with delay
```{r auc plot with delay}
participant_AUCs_filtered <- participant_AUCs %>%
    filter(memory_delay > 5 & memory_delay < 10)

auc_plot <- ggplot(participant_AUCs_filtered, aes(x = as.factor(memory_delay), fill = foil_type, y = AUC)) +
    geom_boxplot(alpha = .7) +
    scale_fill_manual(values = c(color1, color2), name = "Memory Specificity") + 
    xlab("Memory Delay (Days)") +
    ylab("Memory Performance (AUC)") +
    coord_cartesian(ylim = c(.5, 1)) +
    mem_theme
auc_plot
```


# RL modeling
## Choice weights
```{r cbm parameter ests fourB_oneA_oneQ_CF}
#read in param ests
param_ests <- read_csv("data/model_estimates/params_fourB_oneQ_CF.csv")

#merge with age
param_ests <- full_join(param_ests, subject_list, by = c("subject_id"))
```

### Figure 5C: Distribution of choice weights
```{r beta histogram, fig.width = 6, fig.height = 4}

#pivot longer
beta_ests <- param_ests %>%
    pivot_longer(cols = c(beta_c_cCond: beta_e_eCond),
                 names_to = "beta_parameter",
                 names_prefix = "beta_",
                 values_to = "est") %>%
    separate(beta_parameter, into = c("beta_val", "block_condition"), sep = "_") %>%
    drop_na()

beta_ests$abstraction <- factor(beta_ests$beta_val,
                                levels = c("c", "e"),
                                labels = c("category", "exemplar"))

beta_ests$reward_condition <- factor(beta_ests$block_condition,
                                levels = c("cCond", "eCond"),
                                labels = c("Category-Predictive", "Exemplar-Predictive"))

#find means to add to plot
beta_means <- beta_ests %>%
    group_by(reward_condition, abstraction, age_group) %>%
    summarize(mean_est = mean(est, na.rm = T))

#plot
beta_histogram <- ggplot(beta_ests, aes(x = est)) +
    facet_grid(rows = vars(abstraction), cols = vars(age_group)) + 
    geom_histogram(position = "identity", color = 'black', aes(fill = reward_condition), alpha = .4) +
    geom_vline(data = beta_means, aes(xintercept = mean_est, color = reward_condition), linewidth = 2) + 
    xlab("Choice Weight Magnitude") +
    ylab("Number of Participants") +
    scale_y_continuous(breaks = c(0, 3, 6, 9)) +
    scale_fill_manual(values = c(color1, color2), name = "Block Condition") +
    scale_color_manual(values = c(color1, color2), name = "Block Condition") +
    mem_theme +
    theme(legend.position = "top")
beta_histogram
```


### Model: Choice weights by block condition and age group
```{r fit choice weight by age group model}

#factor age group
beta_ests$age_group <- factor(beta_ests$age_group)

#do betas change across conditions and by age?
beta.age.model <- mixed(est ~ abstraction * reward_condition * age_group + (1|subject_id),
                            method = "S",
                        data = beta_ests)
nice(beta.age.model) 

#effect of
# abstraction x reward condition 
```

```{r display choice weight by age group model}
beta.age.model.lmer <- mixed(est ~ abstraction * reward_condition * age_group + (1|subject_id),
                            method = "S",
                           data = beta_ests,
                           return = "merMod")

tab_model(beta.age.model.lmer,
          digits = 4,
          show.intercept = F,
          show.est = T,
          show.ci = F,
          show.se = T,
          show.stat = F,
          show.p = F,
          string.se = "SE")
```


### Model: Exemplar choice weights by condition
```{r fit exemplar choice weight by condition model}

#filter data
exemp_beta_ests <- beta_ests %>%
    filter(abstraction == "exemplar")

#do betas change across conditions and by age group?
beta.age.model.exemp <- mixed(est ~ reward_condition + (1|subject_id),
                            method = "S",
                           data = exemp_beta_ests)
nice(beta.age.model.exemp) 

# no effects
```


```{r display exemplar choice weight by condition model}
beta.age.model.exemp.lmer <- mixed(est ~ reward_condition + (1|subject_id),
                                   method = "S",
                                   data = exemp_beta_ests,
                                   return = "merMod")

tab_model(beta.age.model.exemp.lmer,
          digits = 4,
          show.intercept = F,
          show.est = T,
          show.ci = F,
          show.se = T,
          show.stat = F,
          show.p = F,
          string.se = "SE")
```


### Model: Category choice weights by condition
```{r fit category choice weight by condition model}

#filter and scale age
cat_beta_ests <- beta_ests %>%
    filter(abstraction == "category")

#do betas change across conditions and by age?
beta.age.model.cat <- mixed(est ~ reward_condition + (1|subject_id),
                            method = "S",
                           data = cat_beta_ests)
nice(beta.age.model.cat) 

#effect of reward condition
```

```{r display category choice weight by condition model}
beta.age.model.cat.lmer <- mixed(est ~ reward_condition + (1|subject_id),
                                   method = "S",
                                   data = cat_beta_ests,
                                   return = "merMod")

tab_model(beta.age.model.cat.lmer,
          digits = 4,
          show.intercept = F,
          show.est = T,
          show.ci = F,
          show.se = T,
          show.stat = F,
          show.p = F)
```

### Relations between choice weights and points earned
```{r choice weights points data processing}
participant_points <- learning_data %>%
    group_by(subject_id, reward_condition) %>%
    summarize(total_points = sum(points, na.rm = T)) 

beta_ests$subject_id <- factor(beta_ests$subject_id)

beta_ests_points <- full_join(participant_points, beta_ests, by = c("subject_id", "reward_condition"))
```

```{r fit choice weights points model}

#drop na
beta_ests_points <- beta_ests_points %>%
    select(est, total_points, age, age_group, abstraction, reward_condition, subject_id) %>%
    drop_na()

#scale beta estimate
beta_ests_points$beta_scaled <- scale_this(beta_ests_points$est)

#do beta values predict points?
beta_points_model <- mixed(total_points ~ age_group * beta_scaled * abstraction * reward_condition + (1|subject_id),
                           data = beta_ests_points)
beta_points_model

# effects of 
# age group
# beta
# reward condition
# age group x reward condition
# beta x reward condition
# beta x abstraction x reward condition
```

```{r fit separate regressions to look at how exemplar and category choice weights influence points across conditions}

#drop na
beta_ests_points_c_c <- beta_ests_points %>%
    filter(reward_condition == "Category-Predictive",
           abstraction == "category")

beta_ests_points_e_c <- beta_ests_points %>%
    filter(reward_condition == "Category-Predictive",
           abstraction == "exemplar")

beta_ests_points_c_e <- beta_ests_points %>%
    filter(reward_condition == "Exemplar-Predictive",
           abstraction == "category")

beta_ests_points_e_e <- beta_ests_points %>%
    filter(reward_condition == "Exemplar-Predictive",
           abstraction == "exemplar")

#do beta values predict points?
beta_points_model1 <- lm(total_points ~ est, data = beta_ests_points_c_c)
beta_points_model2 <- lm(total_points ~ est, data = beta_ests_points_e_c)
beta_points_model3 <- lm(total_points ~ est, data = beta_ests_points_c_e)
beta_points_model4 <- lm(total_points ~ est, data = beta_ests_points_e_e)

summary(beta_points_model1) #sig
summary(beta_points_model2) #sig
summary(beta_points_model3) #not sig
summary(beta_points_model4) #sig
```


### Supplementary Figure: Points earned vs. beta values
```{r points and choice weights plot}

points_beta_plot <- ggplot(beta_ests_points, aes(x = est, y = total_points, color = abstraction)) +
    facet_grid(cols = vars(reward_condition)) +
    geom_point() +
    geom_smooth(method = "lm", aes(fill = abstraction)) +
    scale_color_manual(values = c(color1, color2), name = "Choice Weight") + 
    scale_fill_manual(values = c(color1, color2), name = "Choice Weight") +
    ylab("Total Points Earned") +
    xlab("Choice Weight Magnitude") +
    mem_theme +
    theme(legend.position = "top")
points_beta_plot
```


# Relations between learning and memory
```{r auc points data processing}
temp <- aucs %>%
    select(subject_id, memory_delay, reward_condition, abstraction = foil_type, age_group, age, AUC)

temp$subject_id <- factor(temp$subject_id)

#join data
auc_beta_points <- full_join(temp, beta_ests_points, by = c("subject_id", "reward_condition", "abstraction", "age_group", "age"))

```

## Do points earned during learning relate to memory?

### Model: AUC by points earned, reward condition, age group 
```{r auc points relation}

#does the number of points participants earned in each block relate to memory performance?
auc_beta_points$age_group  <- factor(auc_beta_points$age_group)
auc_beta_points$points_scaled  <- scale_this(auc_beta_points$total_points)

auc_beta_points_model <- mixed(AUC ~ age_group * points_scaled * abstraction * reward_condition + (1|subject_id),
                                  method = "S",
                                  data = auc_beta_points)
nice(auc_beta_points_model) 

# main effect of points - participants who earned more points had better memory
# age group x abstraction x reward condition 
# points x abstraction x reward condition

```

```{r display auc points model}

auc_beta_points_model.lmer <- mixed(AUC ~ age_group * points_scaled * abstraction * reward_condition + (1|subject_id),
                                  method = "S",
                                  data = auc_beta_points,
                                  return = "merMod")

tab_model(auc_beta_points_model.lmer,
          digits = 4,
          show.intercept = F,
          show.est = T,
          show.ci = F,
          show.se = T,
          show.stat = F,
          show.p = F,
          string.se = "SE")
```


### Figure 5E: AUC by performance group and reward condition
```{r auc points participant plot, fig.height = 8, fig.width = 5}

auc_beta_points <- auc_beta_points %>%
    group_by(reward_condition) %>%
    mutate(performance_group = ntile(total_points, 2))

auc_beta_points$performance_group <- factor(auc_beta_points$performance_group,
                                            levels = c(1, 2),
                                            labels = c("low point-earners", "high point-earners"))

auc_beta_points_means <- auc_beta_points %>%
    group_by(performance_group, abstraction, reward_condition) %>%
    summarize(mean_auc = mean(AUC, na.rm = T),
              N = n(),
              se_auc = sd(AUC)/sqrt(N))

auc_points_plot <- ggplot(auc_beta_points) +
    facet_grid(cols = vars(performance_group), rows = vars(abstraction)) +
      geom_hline(yintercept = .5, linetype = "dashed") +
    geom_point(data = auc_beta_points, aes(x = reward_condition, color = abstraction, y = AUC), shape = 95, size = 30, alpha = .2) + 
    geom_point(data = auc_beta_points_means, aes(x = reward_condition, y = mean_auc), color = "black", size = 2) +
    geom_errorbar(data = auc_beta_points_means, aes(x = reward_condition, y = mean_auc, ymin = mean_auc - se_auc, ymax = mean_auc + se_auc), color = "black", width = .1) +
    geom_line(data = auc_beta_points_means, aes(x = reward_condition, y = mean_auc, group = performance_group), color = "black", size = .5) +
    scale_color_manual(values = c(color1, color2), name = "Block Condition") +
    xlab("Block Condition") +
    ylab("Memory Performance (AUC)") +
    mem_theme +
    theme(axis.text.x = element_text(angle = 50, hjust = 1),
          legend.position = "none")
auc_points_plot
```


## Do choice weights relate to memory?
```{r auc beta data processing}
temp <- aucs %>%
    select(subject_id, memory_delay, reward_condition, abstraction = foil_type, age_group, age, AUC)

temp$subject_id <- factor(temp$subject_id)

#join data
auc_beta <- full_join(temp, beta_ests, by = c("subject_id", "reward_condition", "abstraction", "age_group", "age"))

```

### Model: AUC by age group, exemplar choice weights, specificity, block condition 
```{r fit auc exemplar choice weights model}

#join data
beta_ests_exemplar <- beta_ests %>%
    filter(abstraction == "exemplar") %>%
    select(subject_id, est, reward_condition)

auc_beta_exemplar <- full_join(temp, beta_ests_exemplar, by = c("subject_id", "reward_condition"))

#scale variables
auc_beta_exemplar$beta_scaled <-scale_this(auc_beta_exemplar$est)
auc_beta_exemplar$age_group  <-factor(auc_beta_exemplar$age_group)

auc_beta_exemplar_model <- mixed(AUC ~ age_group * beta_scaled * abstraction * reward_condition + (1|subject_id),
                                  method = "S",
                                  data = auc_beta_exemplar)
nice(auc_beta_exemplar_model) 

# effects of 
# beta
# abstraction
# reward condition
# age group x beta
```

```{r display auc exemplar choice weights model}

auc_beta_exemplar_model.lmer <- mixed(AUC ~ age_group * beta_scaled * abstraction * reward_condition + (1|subject_id),
                                  method = "S",
                                  data = auc_beta_exemplar,
                                  return = "merMod")

tab_model(auc_beta_exemplar_model.lmer,
          digits = 4,
          show.intercept = F,
          show.est = T,
          show.ci = F,
          show.se = T,
          show.stat = F,
          show.p = F,
          string.se = "SE")
```


### Figure 5F: AUC by exemplar choice weights: model effects
```{r plot auc by exemplar choice weights model effects, fig.width = 10}

sjPlot::set_theme( 
    base = theme_classic(),
    legend.item.backcol = "transparent",
    geom.boxoutline.color = "black",
    axis.textsize = 1,
    axis.textcolor = "black",
    axis.title.color = "black",
    axis.title.size = 1.1,
    axis.title.x.vjust = -.25,
    axis.title.y.vjust = 1,
    legend.title.size = 1.05)


plot_model(auc_beta_exemplar_model.lmer,  type = "pred",
           terms = c("beta_scaled", "age_group", "reward_condition", "abstraction"),
           colors = c("#FFCA4B", "#45b5aa")) +
        scale_color_manual(values = c(color1, color3), name = "Age Group") +
        scale_fill_manual(values = c(color1, color3), name = "Age Group") 
```

### Model: AUC by age group, category choice weights, specificity, block condition 
```{r fit auc category choice weights model}

#join data
beta_ests_cat <- beta_ests %>%
    filter(abstraction == "category") %>%
    select(subject_id, est, reward_condition)

auc_beta_cat <- full_join(temp, beta_ests_cat, by = c("subject_id", "reward_condition"))

#scale variables
auc_beta_cat$beta_scaled <-scale_this(auc_beta_cat$est)
auc_beta_cat$age_group  <-factor(auc_beta_cat$age_group)

#fit model
auc_beta_cat_model <- mixed(AUC ~ age_group * beta_scaled * abstraction * reward_condition + (1|subject_id),
                                  method = "S",
                                  data = auc_beta_cat)
nice(auc_beta_cat_model) 

#effects of 
# abstraction
# block condition
# beta x abstraction
# age group x beta x reward condition
```

```{r display auc category choice weights model}

auc_beta_cat_model.lmer <- mixed(AUC ~ age_group * beta_scaled * abstraction * reward_condition + (1|subject_id),
                                  method = "S",
                                  data = auc_beta_cat,
                                  return = "merMod")

tab_model(auc_beta_cat_model.lmer,
          digits = 4,
          show.intercept = F,
          show.est = T,
          show.ci = F,
          show.se = T,
          show.stat = F,
          show.p = F,
          string.se = "SE")
```


### Figure 5F: AUC by category choice weights: model effects
```{r plot auc by cat choice weights model effects, fig.width = 10}

sjPlot::set_theme( 
    base = theme_classic(),
    legend.item.backcol = "transparent",
    geom.boxoutline.color = "black",
    axis.textsize = 1,
    axis.textcolor = "black",
    axis.title.color = "black",
    axis.title.size = 1.1,
    axis.title.x.vjust = -.25,
    axis.title.y.vjust = 1,
    legend.title.size = 1.05)


plot_model(auc_beta_cat_model.lmer,  type = "pred",
           terms = c("beta_scaled", "age_group", "reward_condition", "abstraction"),
           colors = c("#FFCA4B", "#45b5aa")) +
        scale_color_manual(values = c(color1, color3), name = "Age Group") +
        scale_fill_manual(values = c(color1, color3), name = "Age Group") 
```



# Relations between age group and other model parameters
## Model: Alpha choice values by age group
```{r alpha values by age model}

#run model
alpha_model <- lm(alpha ~ age_group, data = param_ests)

summary(alpha_model)

#no effect of age group
```


## Model: Alpha cf values by age group
```{r alpha cf values by age model}

#run model
alpha_cf_model <- lm(alpha_cf ~ age_group, data = param_ests)
summary(alpha_cf_model)

#no effect of age group
```


## Model: Initial Q by age
```{r initial q values by age model}

#run model
q_init_model <- lm(q_init ~ age_group, data = param_ests)

summary(q_init_model) 
#no effect of age
```